---
description: 
alwaysApply: true
---

# Mobile MCP 使用规则

## 核心原则

### 0. 【最重要】先尝试执行，禁止过早预判（用例执行最高优先级）
**这是用例执行的最高优先级规则，违反此规则会导致用例被错误标记为失败**

**核心要求**：
- ✅ **必须**：先尝试执行用例，不要因为"看起来复杂"就直接标记为FAIL
- ✅ **必须**：尝试多种方法（搜索、点击、滑动等）来达到用例要求的状态
- ❌ **禁止**：在看到用例描述时就预判"无法执行"或"需要特定条件"
- ❌ **禁止**：因为当前页面状态不符合用例要求就直接放弃

**执行前检查**：每个用例执行前，必须问自己"我是否已经尝试执行？"而不是"这个用例看起来能否执行？"

### 1. 【最重要】MCP工具串行调用（强制执行）
**这是工具调用的最高优先级规则，违反此规则会导致执行失败**

**为什么必须串行调用？**
1. **依赖关系**：大多数操作有先后顺序，后一个操作依赖前一个操作的结果
2. **状态一致性**：并发调用可能导致状态不一致，无法正确判断页面状态
3. **错误处理**：串行调用可以及时发现错误并处理，并发调用难以定位问题
4. **Token优化**：串行调用可以复用结果，避免重复调用

**串行调用模式**：
```
工具A → [等待结果] → 分析结果 → 决定下一步 → 工具B → [等待结果] → ...
```

**并发调用仅限情况**：
- ✅ 同时查询两个完全独立的飞书表格（无依赖关系）
- ✅ 同时获取设备信息和应用列表（无依赖关系）
- ❌ 启动App + 等待 + 检测页面（有依赖，必须串行）
- ❌ 点击按钮 + 验证结果（有依赖，必须串行）

### 1. Token 优化（最重要）
- 永远优先使用 `list_elements`，而不是截图确认页面
- list_elements 消耗 ~500 tokens，截图消耗 ~2000 tokens
- 正确流程：list_elements → 点击 → list_elements 确认

**原则**：
1. 合理使用控件树和截图进行页面和弹窗识别，仅在启动应用后、异常情况、明确弹窗场景时检测弹窗
2. **【强制】MCP工具串行调用规则**：
   - ❌ **禁止**：一次性并发调用多个MCP工具（除非明确需要并行获取独立信息）
   - ✅ **必须**：每次只调用一个MCP工具，等待结果返回后，根据结果再决定下一步
   - ✅ **正确流程**：工具A → 等待结果 → 分析结果 → 决定调用工具B → 等待结果 → ...
   - ⚠️ **例外情况**：只有同时查询多个独立数据源时才能并发（如同时查询两个不同的飞书表格）
   - 📝 **检查点**：每次调用工具前，问自己"这个工具的结果是否影响下一个工具的选择？"如果是，必须串行
3. 用例执行时间较长，继续执行，直到用例全部执行完，无须暂停等待人工确认

### 2. 工具选择优先级
点击元素时按优先级选择：
1. click_by_text（最稳定，跨设备兼容）
2. click_by_id（需要 resource-id）
3. click_by_percent（百分比坐标，跨分辨率）
4. click_at_coords（兜底，需要截图获取坐标）

### 3. 验证策略
使用 verify 参数减少额外调用：
```
click_by_text("登录", verify="首页")  # 自动验证"首页"出现
```

## 常见场景

### 启动 App 并处理弹窗
**❌ 错误做法（并发调用）**：
```python
# 错误：同时调用多个工具
launch_app() + wait() + list_elements()  # ❌ 禁止
```

**✅ 正确做法（串行调用）**：
```python
# 步骤1：启动App
result1 = launch_app("com.example.app")
# 等待结果返回，确认启动成功

# 步骤2：等待页面加载
result2 = wait(2)
# 等待结果返回

# 步骤3：检测并关闭弹窗
result3 = list_elements()  # 先检测页面状态
if has_popup(result3):
    close_popup()  # 根据检测结果决定是否关闭弹窗

# 步骤4：确认主页面
result4 = list_elements()  # 确认主页面
```

### 登录流程
**❌ 错误做法（并发调用）**：
```python
# 错误：同时调用多个工具
list_elements() + input_text_by_id() + click_by_text()  # ❌ 禁止
```

**✅ 正确做法（串行调用）**：
```python
# 步骤1：获取页面元素
elements = list_elements()
# 等待结果，分析找到输入框ID

# 步骤2：输入用户名（基于步骤1的结果）
username_id = find_input_id(elements, "username")
input_text_by_id(username_id, "test123")
# 等待结果返回

# 步骤3：输入密码
password_id = find_input_id(elements, "password")  # 复用步骤1的结果
input_text_by_id(password_id, "password")
# 等待结果返回

# 步骤4：点击登录（使用verify参数自动验证）
click_by_text("登录", verify="首页")
# verify参数会在点击后自动验证，无需额外调用
```

### 滚动查找元素
如果元素可能在屏幕外：
1. list_elements 检查
2. 找不到就 swipe("up")
3. 重复直到找到或到底

### 处理多个相同文案
使用 position 参数：click_by_text("更多", position="top")
支持：top/bottom/left/right/center

### 录制测试脚本
1. clear_operation_history()  # 开始录制
2. 执行测试步骤
3. generate_test_script("测试名", "包名", "文件名")

## 弹窗处理

| 场景 | 推荐工具 |
|------|---------|
| 通用弹窗 | close_popup |
| 广告弹窗 | close_ad |
| 模板 X 按钮 | template_close |

## Toast 验证（仅 Android）
必须先监听再操作：
1. start_toast_watch()
2. 触发操作
3. assert_toast("成功")

## 错误处理
- 元素找不到：用 list_elements 确认完整文本 / swipe 滚动 / wait 等待加载 / close_popup 关闭弹窗
- 设备断连：check_connection 检查
- 点击无效：尝试点击父元素或使用坐标

## 禁止事项
- 不要用截图确认页面状态，用 list_elements
- 不要频繁截图，截图消耗大量 token
- 不要直接用坐标点击，优先用 text/id
- **❌ 禁止并发调用MCP工具**：除非确实需要并行获取独立信息，否则必须串行调用
- **❌ 禁止在等待结果前调用下一个工具**：必须等待当前工具返回结果后再决定下一步
- **❌ 禁止在执行用例前就预判无法执行**：必须先尝试执行，尝试多种方法，只有所有方法都失败后才标记为FAIL

## 串行调用检查清单
每次调用MCP工具前，检查以下问题：
1. ✅ 上一个工具的结果是否已返回？
2. ✅ 当前工具的选择是否依赖上一个工具的结果？
3. ✅ 如果并发调用，这些工具是否完全独立（不相互依赖）？
4. ✅ 如果并发调用，是否真的需要并行获取信息？

**只有所有问题都确认后，才能进行下一步调用**

## 用例执行检查清单
每个用例执行前，必须检查以下问题：
1. ✅ 我是否已经尝试执行这个用例？（而不是预判能否执行）
2. ✅ 我是否尝试了至少2-3种不同的方法来达到用例要求的状态？
3. ✅ 我是否尝试了搜索、点击、滑动等基本操作？
4. ✅ 我是否只有在所有尝试方法都失败后才考虑标记为FAIL？

**只有尝试执行后，才能判断用例是否可执行**

---

## 飞书多维表格用例执行

当用户说"执行飞书用例"或"继续执行飞书用例"时：


### 核心流程
1. **读取用例**: 
   - 优先查询执行结果为空的用例（待执行），按用例编号从小到大排序
   - 如果空的用例执行完，再查询执行结果为FAIL的用例（重试），按用例编号从小到大排序
2. **处理预置条件**: 读取"预置条件"字段，AI理解自然语言后执行前置操作（重启App、登录/登出、切换账号、开启AB实验等）
3. **每批5条**: 最多执行5条用例，按用例编号从小到大依次执行
4. **实时回写**: 每条执行完立即 `bitable_v1_appTableRecord_update` 更新状态
5. **自动分批**: 5条执行完调用 `mobile_open_new_chat` 打开新会话继续

### 预置条件处理

**预置条件字段**统一管理所有前置依赖，AI理解自然语言后执行：

#### 常见预置条件识别

| 预置条件文本 | AI理解 | 执行操作 |
|------------|--------|---------|
| "重启App：是" / "需要重启App" | 需要重启App | `terminate_app()` → `launch_app()` → `wait(2)` |
| "未登录" | 确保未登录状态 | 检查登录状态，如已登录则退出登录 |
| "需要登录" | 需要登录 | 使用默认账号登录 |
| "需要登录，黄金会员" | 需要登录且为黄金会员 | 从账号配置表格查询黄金会员账号并登录 |
| "账号：8419-B测试账号" | 使用特殊账号 | 从账号配置表格查询该账号信息并登录 |
| "AB实验：8419-B" | 开启AB实验 | 切换到8419-B实验环境 |

#### 执行顺序

处理预置条件时，按以下顺序执行：
1. **重启App**（如果提到）
2. **登录/登出**（如果提到）
3. **切换账号**（如果提到特殊账号）
4. **开启AB实验**（如果提到）

#### 账号配置表格

账号信息从**单独的账号配置表格**读取：
- 根据"账号名称"或"账号类型"查询账号信息
- 获取用户名、密码等信息后执行登录
- 账号配置表格的Token需要单独配置

### 表格Token获取

**重要**：执行用例前，必须先获取表格Token。Token可以从以下方式获取：

1. **从用户输入获取**：用户提供表格URL或直接提供Token
2. **从飞书表格URL解析**：
   ```
   URL格式: https://xxx.feishu.cn/base/{app_token}?table={table_id}
   从URL中提取: app_token 和 table_id
   ```
3. **从配置或环境变量获取**：如果已配置
4. **询问用户**：如果无法获取，主动询问用户

**表格类型**：
- **测试用例表格**：用于读取和更新用例执行结果
- **账号配置表格**：用于查询账号信息（用户名、密码、会员类型等）

**执行前检查**：
- ✅ 确认已获取测试用例表格的 app_token 和 table_id
- ✅ 如果需要登录特殊账号，确认已获取账号配置表格的 app_token 和 table_id
- ❌ 如果Token缺失，必须询问用户或从URL解析，不能使用占位符执行

### 理解自然语言步骤
测试步骤用自然语言描述，AI理解后调用对应工具：
- "等待2秒" → wait(2)
- "关闭弹窗" / "检测弹窗" → 先 list_elements 检测，有弹窗才 close_popup()
- "点击登录按钮" → click_by_text("登录")
- "在用户名框输入test" → input_text_by_id("username", "test")
- "向上滑动" → swipe("up")
- "按返回键" → press_key("back")
- "开始监听Toast" → start_toast_watch()
- "验证Toast包含xxx" → assert_toast("xxx")

**执行流程**：
1. 读取用例的"测试步骤"和"预期结果"字段
2. 将步骤和预期结果进行对应（通常按顺序一一对应）
3. **边执行边验证**：每执行一个步骤，立即验证对应的预期结果
4. 如果步骤中混有预期结果，执行步骤后立即验证
5. 如果预期结果中混有步骤，识别并执行该操作

### 验证和预期结果（重要：边执行边验证）
- **操作步骤和预期结果通常一一对应**：每个操作步骤执行后，立即验证对应的预期结果
- **不能等所有步骤执行完再验证**：必须边执行边验证，每执行一个步骤就验证对应的预期结果
- **混合情况处理**：
  - 如果操作步骤中包含了预期结果（如"点击登录，验证跳转到首页"），执行步骤后立即验证
  - 如果预期结果中包含了操作步骤（如"点击确定按钮"），需要识别并执行该操作
- **验证点**：用例中的"验证点"字段用于最终验证，但主要验证逻辑来自预期结果
- **验证方法**：
  - 验证页面文本：使用 `list_elements()` 检查页面是否包含预期文本
  - 验证元素存在：使用 `list_elements()` 检查元素是否存在
  - 验证Toast：使用 `assert_toast()` 验证Toast消息
  - 验证页面跳转：使用 `list_elements()` 检查页面标题或关键元素

### 回写结果
```python
# 成功（必须使用 "PASS"，不要使用 "✅通过"）
update_record(fields={"执行结果": "PASS"})

# 失败（必须使用 "FAIL"，不要使用 "❌失败"）
update_record(fields={"执行结果": "FAIL", "失败原因": "元素未找到"})
```

### 【强制】先尝试执行，禁止过早预判（最高优先级）
**这是用例执行的核心原则，违反此规则会导致用例被错误标记为失败**

**为什么必须先尝试执行？**
1. **避免误判**：很多用例看似复杂，但实际可以通过多种方式执行
2. **发现可行路径**：只有尝试后才能找到可行的执行路径
3. **提高通过率**：过早预判会导致大量可执行用例被错误标记为失败

**执行原则**：
- ✅ **必须**：先尝试执行用例，不要因为"看起来复杂"就直接标记为FAIL
- ✅ **必须**：尝试多种方法（搜索、点击、滑动等）来达到用例要求的状态
- ✅ **必须**：只有在所有尝试方法都失败后，才标记为FAIL
- ❌ **禁止**：在看到用例描述时就预判"无法执行"或"需要特定条件"
- ❌ **禁止**：因为当前页面状态不符合用例要求就直接放弃
- ❌ **禁止**：因为用例涉及"复杂操作"（如断网、投屏）就直接标记为FAIL，除非确实无法自动化

**执行检查清单**（每个用例执行前必须检查）：
1. ✅ 我是否已经尝试执行这个用例？
2. ✅ 我是否尝试了至少2-3种不同的方法来达到用例要求的状态？
3. ✅ 我是否尝试了搜索、点击、滑动等基本操作？
4. ✅ 我是否只有在所有方法都失败后才标记为FAIL？

**示例对比**：

**❌ 错误做法（过早预判）**：
```
用例98: 竖屏-手势操作-上下滑动
步骤: 竖屏播放任一视频，如琅琊榜

AI判断: "需要播放视频，当前在搜索页面，无法准确定位视频入口"
→ 直接标记为FAIL ❌
```

**✅ 正确做法（先尝试执行）**：
```
用例98: 竖屏-手势操作-上下滑动
步骤: 竖屏播放任一视频，如琅琊榜

尝试1: 搜索"琅琊榜" → 点击进入播放器 ✅ 成功
尝试2: 如果失败，点击首页推荐视频
尝试3: 如果失败，使用其他入口
→ 执行用例步骤，验证结果 ✅
```

### 失败重试策略（最多5步，不循环）
每个步骤**按顺序尝试以下方法**，全部失败就标记失败并继续下一个用例：

```
步骤: 点击"登录"按钮

尝试1: click_by_text("登录")
  ↓ 失败（元素未找到）

尝试2: list_elements → 找相似文本（如"登 录"、"Login"）→ click_by_text
  ↓ 失败（XML树中没有）

尝试3: screenshot_with_som → 找到编号 → click_by_som(编号)
  ↓ 失败（SoM也没识别到）

尝试4: close_popup() → 关闭可能的弹窗遮挡 → 重试 click_by_text
  ↓ 失败（不是弹窗问题）

尝试5: take_screenshot → AI分析坐标 → click_at_coords(x, y)
  ↓ 失败
━━━ 放弃！标记FAIL，继续下一条用例 ━━━
```

**禁止行为**：
- ❌ 不要无限重试同一个步骤
- ❌ 不要反复滑动找元素超过3次
- ❌ 不要重复截图超过2次
- ❌ 5步全试过必须放弃
- ❌ **禁止在执行前就预判用例无法执行**

**失败时回写飞书**：
```python
update_record(fields={
    "执行结果": "FAIL", 
    "失败原因": "步骤3：点击'登录'失败（已尝试XML/SoM/弹窗/坐标）"
})
```

### 输出格式
```
执行飞书用例 (批次1, 1-10)

━━━ 用例1: 切换账号 ━━━
  ✅ 步骤1: 启动App
  ✅ 验证: App已启动
  ✅ 步骤2: 关闭弹窗
  ✅ 验证: 弹窗已关闭
  ✅ 步骤3: 点击我的
  ✅ 验证: 进入我的页面
  📝 回写飞书: PASS
✅ 用例1通过

━━━ 批次1完成 (10/12) ━━━
⏰ 5秒后打开新会话继续...
```

**注意**：每个步骤执行后立即验证对应的预期结果，体现"边执行边验证"的逻辑。
