---
description: 
alwaysApply: true
---

# Mobile MCP 使用规则

## 核心原则

### 0. 【最重要】先尝试执行，禁止过早预判（用例执行最高优先级）
**这是用例执行的最高优先级规则，违反此规则会导致用例被错误标记为失败**

**核心要求**：
- ✅ **必须**：先尝试执行用例，不要因为"看起来复杂"就直接标记为FAIL
- ✅ **必须**：尝试多种方法（搜索、点击、滑动等）来达到用例要求的状态
- ❌ **禁止**：在看到用例描述时就预判"无法执行"或"需要特定条件"
- ❌ **禁止**：因为当前页面状态不符合用例要求就直接放弃

**执行前检查**：每个用例执行前，必须问自己"我是否已经尝试执行？"而不是"这个用例看起来能否执行？"

### 1. 【最重要】MCP工具串行调用（强制执行）
**这是工具调用的最高优先级规则，违反此规则会导致执行失败**

**为什么必须串行调用？**
1. **依赖关系**：大多数操作有先后顺序，后一个操作依赖前一个操作的结果
2. **状态一致性**：并发调用可能导致状态不一致，无法正确判断页面状态
3. **错误处理**：串行调用可以及时发现错误并处理，并发调用难以定位问题
4. **Token优化**：串行调用可以复用结果，避免重复调用

**串行调用模式**：
```
工具A → [等待结果] → 分析结果 → 决定下一步 → 工具B → [等待结果] → ...
```

**并发调用仅限情况**：
- ✅ 同时查询两个完全独立的飞书表格（无依赖关系）
- ✅ 同时获取设备信息和应用列表（无依赖关系）
- ❌ 启动App + 等待 + 检测页面（有依赖，必须串行）
- ❌ 点击按钮 + 验证结果（有依赖，必须串行）

### 1. Token 优化（最重要）
- 参考 Skills 文档中的详细指导
- 【强制】必须遵循 Skills 中的定位优先级策略
2. **【强制】MCP工具串行调用规则**：
   - ❌ **禁止**：一次性并发调用多个MCP工具（除非明确需要并行获取独立信息）
   - ✅ **必须**：每次只调用一个MCP工具，等待结果返回后，根据结果再决定下一步
   - ✅ **正确流程**：工具A → 等待结果 → 分析结果 → 决定调用工具B → 等待结果 → ...
   - ⚠️ **例外情况**：只有同时查询多个独立数据源时才能并发（如同时查询两个不同的飞书表格）
   - 📝 **检查点**：每次调用工具前，问自己"这个工具的结果是否影响下一个工具的选择？"如果是，必须串行
3. 用例执行时间较长，继续执行，直到用例全部执行完，无须暂停等待人工确认

### 2. 工具选择优先级
- 参考 Skills 文档中的详细工具速查表
- 【强制】必须遵循 Skills 中的定位优先级：list_elements > click_by_text > click_by_id > click_by_percent > screenshot_with_som
1. click_by_text（最稳定，跨设备兼容）
2. click_by_id（需要 resource-id）
3. click_by_percent（百分比坐标，跨分辨率）
4. click_at_coords（兜底，需要截图获取坐标）

### 3. 验证策略
- 参考 Skills 文档中的验证策略说明
- 【强制】必须使用 verify 参数减少额外调用

## 常见场景

### 启动 App 并处理弹窗
**❌ 错误做法（并发调用）**：
```python
# 错误：同时调用多个工具
launch_app() + wait() + list_elements()  # ❌ 禁止
```

**✅ 正确做法（串行调用）**：
```python
# 步骤1：启动App
result1 = launch_app("com.example.app")
# 等待结果返回，确认启动成功

# 步骤2：等待页面加载
result2 = wait(2)
# 等待结果返回

# 步骤3：检测并关闭弹窗
result3 = list_elements()  # 先检测页面状态
if has_popup(result3):
    close_popup()  # 根据检测结果决定是否关闭弹窗

# 步骤4：确认主页面
result4 = list_elements()  # 确认主页面
```

### 登录流程
**❌ 错误做法（并发调用）**：
```python
# 错误：同时调用多个工具
list_elements() + input_text_by_id() + click_by_text()  # ❌ 禁止
```

**✅ 正确做法（串行调用）**：
```python
# 步骤1：获取页面元素
elements = list_elements()
# 等待结果，分析找到输入框ID

# 步骤2：如果遇到登录页面，切换到密码登录
if is_login_page(elements):
    click_by_text("密码登录")  # 切换到密码登录
    wait(1)
    elements = list_elements()  # 重新获取页面元素

# 步骤3：从账号配置表格读取账号信息
account_info = get_account_from_table(account_type)  # 根据账号类型查询

# 步骤4：输入用户名（基于步骤1的结果）
username_id = find_input_id(elements, "username")
input_text_by_id(username_id, account_info["username"])
# 等待结果返回

# 步骤5：输入密码
password_id = find_input_id(elements, "password")  # 复用步骤1的结果
input_text_by_id(password_id, account_info["password"])
# 等待结果返回

# 步骤6：⭐ 收起键盘（必须！确保协议复选框不被键盘遮挡）
hide_keyboard()
# 等待键盘收起

# 步骤7：勾选用户协议（如有）
if has_agreement_checkbox(elements):
    click_by_text("我已阅读并同意")

# 步骤8：点击登录（使用verify参数自动验证）
click_by_text("登录", verify="首页")
# verify参数会在点击后自动验证，无需额外调用
```


### 搜索输入流程
**输入文案前，必须先清空搜索框**：
```python
# 步骤1：点击搜索框
click_by_id("search_input")

# 步骤2：清空搜索框（长按全选删除，或点击清空按钮）
# 方法1：查找清空按钮
elements = list_elements()
if has_clear_button(elements):
    click_by_id("clear_button")
else:
    # 方法2：长按全选后删除
    long_press_by_id("search_input")
    press_key("back")  # 删除选中内容

# 步骤3：输入目标文案
input_text_by_id("search_input", "目标文案")
```

### 滚动查找元素
**如果当前页面找不到某个元素，需要从下往上滑动页面查找元素，最多滑动5次**

**正确流程**：
```python
# 步骤1：list_elements 检查元素是否存在
elements = list_elements()
if has_target_element(elements, "目标元素"):
    # 找到了，直接操作
    click_by_text("目标元素")
else:
    # 步骤2：从下往上滑动查找（最多5次）
    max_swipes = 5
    for i in range(max_swipes):
        swipe("up")  # 从下往上滑动
        wait(1)  # 等待页面加载
        elements = list_elements()
        if has_target_element(elements, "目标元素"):
            click_by_text("目标元素")
            break
    else:
        # 5次滑动后仍未找到，标记失败
        mark_fail("元素未找到（已滑动5次）")
```

**重要规则**：
- ✅ **必须**：从下往上滑动（swipe("up")），而不是从上往下滑动
- ✅ **必须**：最多滑动5次，超过5次仍未找到则放弃
- ✅ **必须**：每次滑动后等待1-2秒，让页面加载完成
- ✅ **必须**：每次滑动后重新调用 list_elements() 检查元素
- ❌ **禁止**：使用 swipe("down") 从上往下滑动查找元素
- ❌ **禁止**：无限滑动查找元素

### 处理多个相同文案
使用 position 参数：click_by_text("更多", position="top")
支持：top/bottom/left/right/center

### 录制测试脚本
1. clear_operation_history()  # 开始录制
2. 执行测试步骤
3. generate_test_script("测试名", "包名", "文件名")

## 弹窗处理

| 场景 | 推荐工具 |
|------|---------|
| 通用弹窗 | close_popup |
| 广告弹窗 | close_ad |
| 模板 X 按钮 | template_close |

## Toast 验证（仅 Android）
必须先监听再操作：
1. start_toast_watch()
2. 触发操作
3. assert_toast("成功")

## 错误处理
- 元素找不到：
  1. 用 list_elements 确认完整文本
  2. **从下往上滑动查找**（swipe("up")，最多5次）
  3. wait 等待加载
  4. close_popup 关闭弹窗
  5. 如果5次滑动后仍未找到，标记失败
- 设备断连：check_connection 检查
- 点击无效：尝试点击父元素或使用坐标

## 禁止事项
- 不要用截图确认页面状态，用 list_elements
- 不要频繁截图，截图消耗大量 token
- 不要直接用坐标点击，优先用 text/id
- **❌ 禁止并发调用MCP工具**：除非确实需要并行获取独立信息，否则必须串行调用
- **❌ 禁止在等待结果前调用下一个工具**：必须等待当前工具返回结果后再决定下一步
- **❌ 禁止在执行用例前就预判无法执行**：必须先尝试执行，尝试多种方法，只有所有方法都失败后才标记为FAIL

## 串行调用检查清单
每次调用MCP工具前，检查以下问题：
1. ✅ 上一个工具的结果是否已返回？
2. ✅ 当前工具的选择是否依赖上一个工具的结果？
3. ✅ 如果并发调用，这些工具是否完全独立（不相互依赖）？
4. ✅ 如果并发调用，是否真的需要并行获取信息？

**只有所有问题都确认后，才能进行下一步调用**

## 用例执行检查清单
每个用例执行前，必须检查以下问题：
1. ✅ 我是否已经尝试执行这个用例？（而不是预判能否执行）
2. ✅ 我是否尝试了至少2-3种不同的方法来达到用例要求的状态？
3. ✅ 我是否尝试了搜索、点击、滑动等基本操作？
4. ✅ 我是否只有在所有尝试方法都失败后才考虑标记为FAIL？

**只有尝试执行后，才能判断用例是否可执行**

---

## 飞书多维表格用例执行

当用户说"执行飞书用例"或"继续执行飞书用例"时：


### 核心流程
1. **读取用例**: 
   - 优先查询执行结果为空的用例（待执行），按用例编号从小到大排序
   - 如果空的用例执行完，再查询执行结果为FAIL的用例（重试），按用例编号从小到大排序
2. **每条用例执行流程**：
   - **第一步（读取预置条件）**：读取用例的"预置条件"字段
   - **第二步（处理重启App）**：
     - **如果预置条件中明确要求重启App**（如"重启App：是"、"需要重启App"等）：
       - **直接执行重启**：终止应用（terminate_app）→ 重新启动（launch_app）→ 等待2秒
       - 然后检测页面状态，确保在首页
     - **如果预置条件中没有要求重启App**：
       - 检测当前页面状态（list_elements）
       - **如果在首页**：直接执行用例
       - **如果不在首页**：终止应用（terminate_app）再重新启动（launch_app），然后等待2秒，再次检测确保在首页
     - **判断是否在首页的方法**：使用 list_elements() 检测页面是否包含首页特征元素（如搜索框、推荐内容、底部导航栏的"首页"标签等）
   - **第三步（处理其他预置条件）**: 处理其他预置条件（登录/登出、切换账号、开启AB实验等）
   - **第四步（执行用例步骤）**: 按步骤执行，边执行边验证
   - **最后一步（强制）**：用例执行完成后，必须返回到应用首页（确保下一条用例从干净状态开始）
     - **回退到首页的方法**（按优先级尝试）：
       1. **优先**：点击底部导航栏的"首页"标签（click_by_text("首页")），等待1秒后检测是否在首页
       2. **备选**：按返回键（press_key("back")）多次（最多5次），每次等待1秒后检测是否在首页
       3. **兜底**：如果以上方法都失败，终止应用（terminate_app）再重新启动（launch_app），等待2秒
     - **验证是否在首页**：使用 list_elements() 检测页面是否包含首页特征元素（如搜索框、推荐内容、底部导航栏等）
     - **重要**：如果回退失败，下一条用例执行时会检测到不在首页，会自动终止并重新启动应用
3. **每批5条**: 最多执行5条用例，按用例编号从小到大依次执行
4. **实时回写**: 每条执行完立即 `bitable_v1_appTableRecord_update` 更新状态
5. **自动分批**: 5条执行完调用 `mobile_open_new_chat` 打开新会话继续

### 预置条件处理

**预置条件字段**统一管理所有前置依赖，AI理解自然语言后执行：

#### 常见预置条件识别

| 预置条件文本 | AI理解 | 执行操作 |
|------------|--------|---------|
| "重启App：是" / "需要重启App" | 需要重启App | **优先执行**：`terminate_app()` → `launch_app()` → `wait(2)` → 检测是否在首页 |
| "未登录" | 确保未登录状态 | 检查登录状态，如已登录则退出登录（进入【我的】→【设置】→【退出登录】） |
| "需要登录" | 需要登录 | 从账号配置表格读取默认账号类型，执行登录 |
| "需要登录，黄金会员" | 需要登录且为黄金会员 | 从账号配置表格查询"黄金会员"类型账号并登录 |
| "账号：8419-B测试账号" | 使用特殊账号 | 从账号配置表格查询该账号信息并登录 |
| "AB实验：8419-B" | 开启AB实验 | 切换到8419-B实验环境 |

#### 登录/登出操作流程

**退出登录流程**（用例前提为"未登录"时）：
```python
# 步骤1：进入【我的】底tab
click_by_text("我的")

# 步骤2：查找【设置】入口（可能需要从下往上滑动）
elements = list_elements()
if not has_text(elements, "设置"):
    swipe("up")  # 从下往上滑动查找
    elements = list_elements()

# 步骤3：点击【设置】
click_by_text("设置")

# 步骤4：点击【退出登录】
click_by_text("退出登录")

# 步骤5：确认退出（如果有确认弹窗）
wait(1)
elements = list_elements()
if has_text(elements, "确定") or has_text(elements, "确认"):
    click_by_text("确定")  # 或 "确认"
```

**登录流程**（用例前提为"已登录"时）：
```python
# 步骤1：从账号配置表格读取账号信息
# 根据预置条件中的账号类型（如"黄金会员"、"非会员"等）查询账号配置表格
account_info = query_account_table(account_type="黄金会员")  # 示例

# 步骤2：检测是否需要登录（检查当前是否已登录）
elements = list_elements()
if is_login_page(elements):
    # 步骤3：切换到密码登录
    click_by_text("密码登录")
    wait(1)
    elements = list_elements()
    
    # 步骤4：输入账号
    username_id = find_input_id(elements, "username")  # 或查找账号输入框
    input_text_by_id(username_id, account_info["用户名"])
    
    # 步骤5：输入密码
    password_id = find_input_id(elements, "password")  # 或查找密码输入框
    input_text_by_id(password_id, account_info["密码"])
    
    # 步骤6：点击登录
    click_by_text("登录", verify="首页")
```

#### 执行顺序

**重要**：重启App的处理优先级最高，已在用例执行流程的第二步单独处理。

处理预置条件时，按以下顺序执行：
1. **重启App**（如果提到）→ **已在第二步优先执行，此处跳过**
2. **登录/登出**（如果提到）
3. **切换账号**（如果提到特殊账号）
4. **开启AB实验**（如果提到）

**注意**：如果预置条件中明确要求重启App，会在用例执行流程的第二步直接执行重启，然后在第三步处理其他预置条件时跳过重启App的检查，避免重复执行。

#### 账号配置表格

账号信息从**单独的账号配置表格**读取：
- 根据"账号名称"或"账号类型"查询账号信息
- 获取用户名、密码等信息后执行登录
- 账号配置表格的Token需要单独配置

### 表格Token获取

**重要**：执行用例前，必须先获取表格Token。Token可以从以下方式获取：

1. **从用户输入获取**：用户提供表格URL或直接提供Token
2. **从飞书表格URL解析**：
   ```
   URL格式: https://xxx.feishu.cn/base/{app_token}?table={table_id}
   从URL中提取: app_token 和 table_id
   ```
3. **从配置或环境变量获取**：如果已配置
4. **询问用户**：如果无法获取，主动询问用户

**表格类型**：
- **测试用例表格**：用于读取和更新用例执行结果
- **账号配置表格**：用于查询账号信息（用户名、密码、会员类型等）

**执行前检查**：
- ✅ 确认已获取测试用例表格的 app_token 和 table_id
- ✅ 如果需要登录特殊账号，确认已获取账号配置表格的 app_token 和 table_id
- ❌ 如果Token缺失，必须询问用户或从URL解析，不能使用占位符执行

### 理解自然语言步骤
测试步骤用自然语言描述，AI理解后调用对应工具：
- "等待2秒" → wait(2)
- "关闭弹窗" / "检测弹窗" → 先 list_elements 检测，有弹窗才 close_popup()
- "点击登录按钮" → click_by_text("登录")
- "在用户名框输入test" → input_text_by_id("username", "test")
- "搜索xxx" → **先清空搜索框** → input_text_by_id("search_input", "xxx")
- "向上滑动" → swipe("up")
- "按返回键" → press_key("back")
- "收起键盘" → hide_keyboard()
- "勾选协议" / "勾选用户协议" → hide_keyboard() + click_by_text("协议文本")
- "开始监听Toast" → start_toast_watch()
- "验证Toast包含xxx" → assert_toast("xxx")

**执行流程**：
1. 读取用例的"测试步骤"和"预期结果"字段
2. 将步骤和预期结果进行对应（通常按顺序一一对应）
3. **边执行边验证**：每执行一个步骤，立即验证对应的预期结果
4. 如果步骤中混有预期结果，执行步骤后立即验证
5. 如果预期结果中混有步骤，识别并执行该操作

### 验证和预期结果（重要：边执行边验证）
- **操作步骤和预期结果通常一一对应**：每个操作步骤执行后，立即验证对应的预期结果
- **不能等所有步骤执行完再验证**：必须边执行边验证，每执行一个步骤就验证对应的预期结果
- **混合情况处理**：
  - 如果操作步骤中包含了预期结果（如"点击登录，验证跳转到首页"），执行步骤后立即验证
  - 如果预期结果中包含了操作步骤（如"点击确定按钮"），需要识别并执行该操作
- **验证点**：用例中的"验证点"字段用于最终验证，但主要验证逻辑来自预期结果
- **验证方法**：
  - 验证页面文本：使用 `list_elements()` 检查页面是否包含预期文本
  - 验证元素存在：使用 `list_elements()` 检查元素是否存在
  - 验证Toast：使用 `assert_toast()` 验证Toast消息
  - 验证页面跳转：使用 `list_elements()` 检查页面标题或关键元素

### 回写结果
```python
# 成功（必须使用 "PASS"，不要使用 "✅通过"）
update_record(fields={"执行结果": "PASS"})

# 失败（必须使用 "FAIL"，不要使用 "❌失败"）
update_record(fields={"执行结果": "FAIL", "失败原因": "元素未找到"})
```

### 【强制】先尝试执行，禁止过早预判（最高优先级）
**这是用例执行的核心原则，违反此规则会导致用例被错误标记为失败**

**为什么必须先尝试执行？**
1. **避免误判**：很多用例看似复杂，但实际可以通过多种方式执行
2. **发现可行路径**：只有尝试后才能找到可行的执行路径
3. **提高通过率**：过早预判会导致大量可执行用例被错误标记为失败

**执行原则**：
- ✅ **必须**：先尝试执行用例，不要因为"看起来复杂"就直接标记为FAIL
- ✅ **必须**：尝试多种方法（搜索、点击、滑动等）来达到用例要求的状态
- ✅ **必须**：只有在所有尝试方法都失败后，才标记为FAIL
- ❌ **禁止**：在看到用例描述时就预判"无法执行"或"需要特定条件"
- ❌ **禁止**：因为当前页面状态不符合用例要求就直接放弃
- ❌ **禁止**：因为用例涉及"复杂操作"（如断网、投屏）就直接标记为FAIL，除非确实无法自动化

**执行检查清单**（每个用例执行前必须检查）：
1. ✅ 我是否已经尝试执行这个用例？
2. ✅ 我是否尝试了至少2-3种不同的方法来达到用例要求的状态？
3. ✅ 我是否尝试了搜索、点击、滑动等基本操作？
4. ✅ 我是否只有在所有方法都失败后才标记为FAIL？

**示例对比**：

**❌ 错误做法（过早预判）**：
```
用例98: 竖屏-手势操作-上下滑动
步骤: 竖屏播放任一视频，如琅琊榜

AI判断: "需要播放视频，当前在搜索页面，无法准确定位视频入口"
→ 直接标记为FAIL ❌
```

**✅ 正确做法（先尝试执行）**：
```
用例98: 竖屏-手势操作-上下滑动
步骤: 竖屏播放任一视频，如琅琊榜

尝试1: 搜索"琅琊榜" → 点击进入播放器 ✅ 成功
尝试2: 如果失败，点击首页推荐视频
尝试3: 如果失败，使用其他入口
→ 执行用例步骤，验证结果 ✅
```

### 失败重试策略（最多5步，不循环）
每个步骤**按顺序尝试以下方法**，全部失败就标记失败并继续下一个用例：

```
步骤: 点击"登录"按钮

尝试1: click_by_text("登录")
  ↓ 失败（元素未找到）

尝试2: list_elements → 找相似文本（如"登 录"、"Login"）→ click_by_text
  ↓ 失败（XML树中没有）

尝试3: screenshot_with_som → 找到编号 → click_by_som(编号)
  ↓ 失败（SoM也没识别到）

尝试4: close_popup() → 关闭可能的弹窗遮挡 → 重试 click_by_text
  ↓ 失败（不是弹窗问题）

尝试5: take_screenshot → AI分析坐标 → click_at_coords(x, y)
  ↓ 失败
━━━ 放弃！标记FAIL，继续下一条用例 ━━━
```

**禁止行为**：
- ❌ 不要无限重试同一个步骤
- ❌ 不要反复滑动找元素超过3次
- ❌ 不要重复截图超过2次
- ❌ 5步全试过必须放弃
- ❌ **禁止在执行前就预判用例无法执行**

**失败时回写飞书**：
```python
update_record(fields={
    "执行结果": "FAIL", 
    "失败原因": "步骤3：点击'登录'失败（已尝试XML/SoM/弹窗/坐标）"
})
```

### 输出格式
```
执行飞书用例 (批次1, 1-10)

━━━ 用例1: 切换账号 ━━━
  ✅ 步骤1: 启动App
  ✅ 验证: App已启动
  ✅ 步骤2: 关闭弹窗
  ✅ 验证: 弹窗已关闭
  ✅ 步骤3: 点击我的
  ✅ 验证: 进入我的页面
  📝 回写飞书: PASS
✅ 用例1通过

━━━ 批次1完成 (10/12) ━━━
⏰ 5秒后打开新会话继续...
```

**注意**：每个步骤执行后立即验证对应的预期结果，体现"边执行边验证"的逻辑。
